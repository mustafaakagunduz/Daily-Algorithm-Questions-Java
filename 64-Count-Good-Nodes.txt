BASİTÇE:

class Solution {
    public int goodNodes(TreeNode root) {
        if (root == null)
            return 0;

        return dfs(root, Integer.MIN_VALUE);
    }

    private int dfs(TreeNode root, int max) {
        
        if (root == null)
            return 0;
        
        max = Math.max(root.val, max);
        
        if (root.val >= max)
            return 1 + dfs(root.left, max) + dfs(root.right, max);
        else
            return dfs(root.left, max) + dfs(root.right, max);
    }
}

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    /**
     * Bir binary tree'deki "iyi düğüm" sayısını hesaplar.
     * Bir düğüm, kök düğümden o düğüme giden yoldaki tüm düğümlerin
     * değerleri, kendisinin değerinden küçük veya eşitse "iyi düğüm" olarak kabul edilir.
     *
     * @param root Binary tree'nin kök düğümü
     * @return Tree'deki "iyi düğüm" sayısı
     */
    public int goodNodes(TreeNode root) {
        return countGoodNodes(root, Integer.MIN_VALUE);
    }
    
    /**
     * Binary tree'deki "iyi düğüm" sayısını hesaplayan yardımcı metod.
     * Bir düğüm, yolundaki en büyük değere eşit veya daha büyükse "iyi düğüm"dür.
     *
     * @param currentNode İncelenen mevcut düğüm
     * @param maxValueInPath Kökten mevcut düğüme kadar olan yoldaki en büyük değer
     * @return Alt ağaçtaki "iyi düğüm" sayısı
     */
    private int countGoodNodes(TreeNode currentNode, int maxValueInPath) {
        // Base case: Eğer düğüm null ise, alt ağaçta "iyi düğüm" yoktur
        if (currentNode == null) {
            return 0;
        }
        
        // Mevcut düğümün değeri, yoldaki en büyük değere eşit veya daha büyükse,
        // bu düğüm "iyi düğüm"dür
        int goodNodesCount = currentNode.val >= maxValueInPath ? 1 : 0;
        
        // Yoldaki maksimum değeri güncelle
        int newMaxValueInPath = Math.max(maxValueInPath, currentNode.val);
        
        // Sol ve sağ alt ağaçlardaki "iyi düğüm" sayılarını hesapla ve topla
        goodNodesCount += countGoodNodes(currentNode.left, newMaxValueInPath);
        goodNodesCount += countGoodNodes(currentNode.right, newMaxValueInPath);
        
        return goodNodesCount;
    }
}
